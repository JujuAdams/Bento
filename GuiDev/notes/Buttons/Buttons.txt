Juju: This is a discussion surrounding the topic of buttons. For a practical example, please see
      `GuiExampleButton`.
      
Within the Gui system, buttons are instances that:
 1) Have the behavior `GUI_BEHAVIOR_BUTTON`
 2) Can be hovered by the cursor
 3) Will retain cursor focus when using the `GUI_NAV_GAMEPAD` navigation mode
Buttons can be clicked using the primary action too, though not all buttons will always utilise
this feature. For example, a volume slider will respond to left/right input rather than clicking
when using `GUI_NAV_GAMEPAD`. No other Gui instance behavior will capture cursor focus in
`GUI_NAV_GAMEPAD` mode. Buttons are the basic unit of an interactive interface and should be used
frequently.

Button objects that you create should inherit from `GuiButtonObject` (via intermediate objects as
you wish). In this example project, `GuiExampleButton` inherits from `GuiParentButton` which in
turn inherits from `GuiButtonObject`. `GuiExampleScroller` and `GuiExampleCarousel` also inherit
from `GuiButtonObject` and function as examples of buttons that have more complex behavior than
simply being clicked. Buttons objects will typically use three events:
 1) Create event
 2) User Event 0 - Gui update event `GUI_USER_EVENT_STEP`
 3) User Event 1 - Gui draw event `GUI_USER_EVENT_DRAW`
The Create event should be used to initialize variables that are relevant to the button. This might
include variables that describe the color of the button in various states, the sprite to use to
draw the button, and the text label for the button. The Create event functions as any other Create
event in any other GameMaker instance.

As with other Gui instances, there are two special variables that you can set: `width` and
`height`. All Gui instances are presumed to be rectangles for the purpose of positioning and mouse
detection. These `width` and `height` variables will set the size of the rectangle that defines
the instance within the Gui system. `x` and `y` are relevant for the Gui system too and these two
variables will always be treated as the center-middle of the Gui instance.

User Event 0 is used by the Gui system to update the state of the button. User Event 0, if it needs
to be executed, will be executed by `GuiStep()`. Please see `oMain` for more information on this
function. As previously mentioned, User Event 0 may not always be executed due to the internal
logic of the Gui system. For example, if the parent instance for the button is set to invisible
(`visible = false;`) then it and all child instances will be skipped by `GuiStep()` and won't have
their User Event 0 executed.

User Event 0 should be where you check and modify the state of the button. There are many getters
available for use with Gui instances in general and buttons specifically. You can see a list of
getters in the `Library/Nav Getters/` folder in the IDE Asset Browser. Each function has a brief
description at the top. Of particular interest is the triplet of functions `GuiNavGetPress()`,
`GuiNavGetHold()` and `GuiNavGetRelease()`. These three functions detect the state of the primary
action as it relates to the button instance. You will also find `GuiScrollOnPointer()` helpful when
putting buttons into scroll regions.

User Event 1 is executed similarly to User Event 0, but this time it is executed by `GuiDraw()`.
Again, please see `oMain` for more information on this function. You should do all drawing for a
button in User Event 1. You may use any GameMaker drawing techniques - including matrices, shaders,
and surfaces - without limitation. However, the Gui system's scroll region feature uses the stencil
buffer and, as such, you may not use custom stencil buffer code. If you'd like to temporarily
disable the stencil buffer (for example, to draw a selection indicator without it being clipped by
the scroll region) then you can do so by calling `GuiScrollClipOff()`. You must always call
`GuiScrollClipOn()` at some point after `GuiScrollClipOff()` to ensure scroll regions render
correctly.