# Building From BentoScript

&nbsp;

BentoScript is the language that Bento uses to describe UI layouts (as well as UI behaviour). BentoScript is a modified version of [Catspeak]() by [Katsaii](), a language specifically designed to work smoothly with GameMaker. BentoScript is compiled at runtime by the library and therefore can, and does, support live updating of UI layouts.

&nbsp;

## BentoScript Overview

BentoScript isn't a million miles away from GML and if you're comfortable with GML then you'll get to grips with it quickly:

- BentoScript is sandboxed. To access anything in your project (functions, objects, sprites, sounds, etc.) you'll need to explicitly whitelist it.

- Variables are weakly typed. Variables can be booleans, numbers, strings, arrays, structs, functions, or undefined. Struct/array literals are supported.

- There are no methods, only simple functions. Every function is called in the current scope.

- There are only `while` loops. The other types of loops in GML (`for` `repeat` `do...until` `with`) aren't supported.

- `switch...case` statements aren't supported either.

- Functions are defined using the abbreviation `fn` (instead of GML's `function`).

- Function definitions come up a lot when defining callbacks and most callbacks don't receive arguments. If a function has no arguments then instead of typing `fn()` you can shorten it further to `fn`.

- A new command `build` has been added to assist with creating a UI tree (`build` replaces Catspeak's native `use`, though it returns the result of the close function).

- BentoScript doesn't support the unary operators `++` or `--` (use `+= 1` or `-= 1` respectively).

&nbsp;

## Executing BentoScript

Code stored in BentoScript files can be executed using a few different GML functions:

- `BentoFileExecuteLayerTop()`
- `BentoFileExecuteLayerOver()`
- `BentoFileExecuteLayerPriority()`

Mostly you'll be using the convenience function `BentoFileExecuteLayerTop()` but you can execute BentoScript files using any of the above. Each of these functions creates a new layer and then executes the BentoScript file, placing whatever is generated by that file on the layer.

!> `BentoFileExecute()` exists as well. In general, this function should be avoided unless you're confident you know what you're doing.

Another useful feature is replacing a UI element with the result of executing a file. You can do this two ways: 

1. BentoScript function `BoxReplace()`

2. Method `.ReplaceFromFile()`

Replacing UI elements seems a little strange on the face of it but it is a powerful tool that can be used to create pages of content inside your UI. Instead of regenerating an entire UI layer, you can designate a UI element as a replaceable frame and then replace only that frame. This feature, in combination with some buttons positions as tabs, allows for some very complex behaviour.

Finally, you can also execute a BentoScript string using `BentoStringExecute()`. When you call this function, Bento will parse the string and store the compiled program in an internal cache. Subsequent executions of the string will skip the parsing and compiling stage and will skip straight to execution. `BentoStringExecute()` isn't inherently slower than executing BentoScript from a file but overuse of this functionality may lead to uncomfortable hitching when navigating menus.

&nbsp;

## Building

Building UI with BentoScript is a case of calling the `build` command and targeting a UI class. Anything inside the subsequent curly brackets will be executed in the scope of the new UI element, a little bit like a combination of the `new` command and the `with()` command in GML.

```
build BentoRectangle {
	ltrb = [20, 20, parent.width-20, parent.height-20]
}
```

`build` commands can be nested inside each other. When you execute a build command in the scope of a UI element, the new UI element is added to the old one a child.

```
//This is the parent
build BentoRectangle {
	ltrb = [20, 20, parent.width-20, parent.height-20]

	//This is a child
	build BentoRectangle {
		ltrb = [20, 20, parent.width/2 - 10, parent.height-20]
	}

	//This is another child
	build BentoRectangle {
		ltrb = [parent.width/2 + 10, 20, parent.width - 20, parent.height-20]
	}
}
```

Every UI element you construct in BentoScript will always have a parent. Which UI element is being used as the parent depends on the situation. When using a function like `BentoFileExecuteLayerTop()`, the new layer is the parent for UI elements built in your BentoScript.

The `build` command itself returns the struct that it has created. This means you can use the return value from the `build` command to hold references to UI elements. Consider this example:

```
build BentoRectangle {
	ltrb = [20, 20, parent.width-20, parent.height-20]

	var firstChild = build BentoRectangle {
		ltrb = [20, 20, parent.width/2 - 10, parent.height-20]
	}

	//Create the second rectangle below the first rectangle
	build BentoRectangle {
		x      = topChild.x
		y      = topChild.height + 20
		width  = topChild.width
		height = topChild.height
	}
}
```

In this example, we're creating a local variable (`var firstChild`) that stores a reference to a rectangle. We're then creating a second rectangle beneath it with a 20px space between the two. Both rectangles share the same width and height.

&nbsp;

## Variables

?> You can read a full list of shared variables [here](Shared-Variables). Each UI template also has its own set of special variables specific to that template so make sure to read the documentation thoroughly to understand what's available.

There are many, many variables that you can read and adjust for a UI element. You've seen a few already - `x` `y` `width` `height`. You'll notice a special variable called `ltrb` as well. Variables in BentoScript behave similarly to GML. They're weakly typed to begin with, and variables types can be one of the following: boolean, number, string, array, struct, functions, or undefined. You can create local variables with `var` and variables without a prefix (e.g. `x` as opposed to `topChild.x`) are presumed to be variables available in the current scope.

BentoScript adds an extra feature on top of standard GML variables, however, and that's getter and setter functions for variables. Normally when you get and set a variable in GML you're just reading and writing variables. There's nothing else that happens. In building out Bento, however, I found that it's really useful to execute implicit behaviours when setting variables.

As an example, let's look at `ltrb`. This is a shorthand for "left, top, right, bottom" and, as you might have guessed, this variable sets the bounding box for a UI element based on a 4-element array. Internally, there is no `ltrb` variable. It's a trick! In reality, the `ltrb` variable has special getter and setter functions set up. When you set the `ltrb`variable, the four components of the array are unpacked into separate left, top, right, and bottom variables. When you get the `ltrb` variable, these four components are recombined into an array.

In fact, the majority of variables that you'll use with BentoScript are implemented as getter / setter functions. When building custom UI templates for yourself you'll likely want to be able to define your own getter / setter functions too. You can call the `VariableBind()` method to set up getter / setter functions for yourself.

!> When writing GML code to interface with Bento, it is strongly recommended that you use the `Get()` and `Set()` methods for reading and writing variables. Getter / Setter functions will only work in GML if you use these two methods!

&nbsp;

## Percentages

You'll see in a few places the use of strings that contain a percentage value. Percentage values aren't available for use everywhere, but you'll find them useful when defining the position and size of UI elements. When a percentage value is used, the resulting value passed into Bento is a fraction of the parent's width or height (as is appropriate). For example:

```
build BentoSprite {
	//Stretch the blood splatter sprite over this UI element
	sprite = sprBloodSplatter
	stretch = true

	//Position the sprite towards the upper-centre of the parent
	xy = ["50%", "30%"]

	//Cover most of the width, but less of the height, of the parent
	size = ["90%", "50%"]
}
```

Percentage values are very useful when designing responsive layouts and you'll get a lot of mileage out of them on mobile device especially.

&nbsp;

## Callbacks

?> You can read a full list of shared callbacks [here](Callbacks), and there's a quick reference cheat sheet [here](Shared-Callbacks).

Callbacks are the way Bento passes control to your game when an event happens. This includes straight-forward situations where the player clicks on a button; in this situation, the "Click" callback is executed. You'll naturally want to define what should happen when the player clicks a button individually per button. This is where the special variable `callbackClick` comes in. Here's an example:

```
build BentoButton {
	//Centre the button in the parent
	xy = ["50%", "50%"]

	//Give us a big enough size to click
	size = [200, 100]

	//Listen for the left mouse button
	targetListen = "action"

	//Define a callback for clicking the button
	callbackClick = fn {
		//When clicked, show a message in the debug log
		DebugLog("Ping!")
	}
}
```

The important point to note here is that we define the callback by setting it to a function that we define using the `fn { ... }` syntax. Callbacks must always be defined as functions so that Bento has something to execute when the event occurs.

Some callbacks receive an argument, and the "Click" callback is actually one of those callbacks. If you want your callback to be able to receive an argument (or many arguments) then you can add some brackets to the function definition, as you normally would in GML, to grab those arguments e.g.:

```
build BentoButton {
	//Centre the button in the parent
	xy = ["50%", "50%"]

	//Give us a big enough size to click
	size = [200, 100]

	//Listen for the left mouse button
	targetListen = ["action", "alt"]

	//Define a callback for clicking the button
	callbackClick = fn(buttonName) {
		DebugLog("You pressed \"" + String(buttonName) + "\"")
	}
}
```

&nbap;

## Callback Inheritance

Callbacks have a further property: you can execute the callback for the event from a parent template (constructor). This is done by calling `CallInherited()` or `Super()` in BentoScript, or calling `BentoCallInherited()` in GML. This is especially useful when you want to extend the behaviour of a UI template without overriding the behaviour of that UI template entirely. For example, let's we wanted to play a sound effect when a particular button is highlighted:

```
build BentoButton {
	//Centre the button in the parent
	xy = ["50%", "50%"]

	//Give us a big enough size to click
	size = [200, 100]

	//Listen for the left mouse button
	targetListen = "action"

	//Define a callback for highlighting the button
	callbackEnter = fn(buttonName) {
		//Make sure we call the inherited behaviour
		CallInherited()

		//Play the sound
		AudioPlay(sndSquelch)
	}
}
```

&nbsp;

## Layouts & Methods

?> You can read a full list of shared callbacks [here](Shared-Methods).

Bento's UI elements, in addition to getter / setter variables and callbacks, also have explicit methods calls that you can use. These methods vary from very useful and useful, such as `.Destroy()`, to obscure, such as `ButtonStateSet()`. Some UI templates also have methods and when customising your own UI elements you'll likely want to add your own.

Of particular note, however, are the "layout methods". These methods override the `callbackLayout` and `callbackLayoutCheck` callbacks and set up common layout behaviours. You'll find yourself using these a lot in production as a way to simplify setting up menus and inventories etc.  Here's an example:

```
build BentoBox {
	//Place the menu at the left-hand side of the screen
	ltrb = ["10%", "10%", "40%", "90%"]

	//Set up a vertical list that horizontally centres children for this menu
	LayoutAsVerticalList("center", 20)

	build BentoTextButton {
		label = "New Game"
		size = [200, 50]

		targetList = "action"
		callbackClick = fn {
			ChangePage("new game")
		}
	}

	build BentoTextButton {
		label = "Settings"
		size = [200, 50]

		targetList = "action"
		callbackClick = fn {
			ChangePage("settings")
		}
	}

	build BentoTextButton {
		label = "Quit"
		size = [200, 50]

		targetList = "action"
		callbackClick = fn {
			GameEnd()
		}
	}
}
```

&nbsp;

## Exposing Assets

There are three functions that allow you to expose assets and functions in your GameMaker project to BentoScript. Any asset that you **don't** expose will not be available in BentoScript, and their use may result in errors.

&nbsp;

### `BentoAddBoxType()`

&nbsp;

### `BentoAddFunction()`

&nbsp;

### `BentoAddNativeFunction()`