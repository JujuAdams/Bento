# Building From BentoScript

&nbsp;

BentoScript is the language that Bento uses to describe UI layouts (as well as UI behaviour). BentoScript is a modified version of [Catspeak]() by [Katsaii](), a language specifically designed to work smoothly with GameMaker. BentoScript is compiled at runtime by the library and therefore can, and does, support live updating of UI layouts.

&nbsp;

## BentoScript Overview

BentoScript isn't a million miles away from GML and if you're comfortable with GML then you'll get to grips with it quickly:

- BentoScript is sandboxed. To access anything in your project (functions, objects, sprites, sounds, etc.) you'll need to explicitly whitelist it.

- Variables are weakly typed. Variables can be booleans, numbers, strings, arrays, structs, functions, or undefined. Struct/array literals are supported.

- There are no methods, only simple functions. Every function is called in the current scope.

- There are only `while` loops. The other types of loops in GML (`for` `repeat` `do...until` `with`) aren't supported.

- `switch...case` statements aren't supported either.

- Functions are defined using the abbreviation `fn` (instead of GML's `function`).

- Function definitions come up a lot when defining callbacks and most callbacks don't receive arguments. If a function has no arguments then instead of typing `fn()` you can shorten it further to `fn`.

- A new command `build` has been added to assist with creating a UI tree (`build` replaces Catspeak's native `use`, though it returns the result of the close function).

- BentoScript doesn't support the unary operators `++` or `--` (use `+= 1` or `-= 1` respectively).

&nbsp;

## Executing BentoScript

Code stored in BentoScript files can be executed using a few different GML functions:

- `BentoFileExecuteLayerTop()`
- `BentoFileExecuteLayerOver()`
- `BentoFileExecuteLayerPriority()`

Mostly you'll be using the convenience function `BentoFileExecuteLayerTop()` but you can execute BentoScript files using any of the above. Each of these functions creates a new layer and then executes the BentoScript file, placing whatever is generated by that file on the layer.

!> `BentoFileExecute()` exists as well. In general, this function should be avoided unless you're confident you know what you're doing.

Another useful feature is replacing a UI element with the result of executing a file. You can do this two ways: 

1. BentoScript function `BoxReplace()`

2. Method `.ReplaceFromFile()`

Replacing UI elements seems a little strange on the face of it but it is a powerful tool that can be used to create pages of content inside your UI. Instead of regenerating an entire UI layer, you can designate a UI element as a replaceable frame and then replace only that frame. This feature, in combination with some buttons positions as tabs, allows for some very complex behaviour.

Finally, you can also execute a BentoScript string using `BentoStringExecute()`. When you call this function, Bento will parse the string and store the compiled program in an internal cache. Subsequent executions of the string will skip the parsing and compiling stage and will skip straight to execution. `BentoStringExecute()` isn't inherently slower than executing BentoScript from a file but overuse of this functionality may lead to uncomfortable hitching when navigating menus.

&nbsp;

## Building

Building UI with BentoScript is a case of calling the `build` command and targeting a UI class. Anything inside the subsequent curly brackets will be executed in the scope of the new UI element, a little bit like a combination of the `new` command and the `with()` command in GML.

```
build BentoRectangle {
	ltrb = [20, 20, parent.width-20, parent.height-20]
}
```

`build` commands can be nested inside each other. When you execute a build command in the scope of a UI element, the new UI element is added to the old one a child.

```
//This is the parent
build BentoRectangle {
	ltrb = [20, 20, parent.width-20, parent.height-20]

	//This is a child
	build BentoRectangle {
		ltrb = [20, 20, parent.width/2 - 10, parent.height-20]
	}

	//This is another child
	build BentoRectangle {
		ltrb = [parent.width/2 + 10, 20, parent.width - 20, parent.height-20]
	}
}
```

Every UI element you construct in BentoScript will always have a parent. Which UI element is being used as the parent depends on the situation. When using a function like `BentoFileExecuteLayerTop()`, the new layer is the parent for UI elements built in your BentoScript.

The `build` command itself returns the struct that it has created. This means you can use the return value from the `build` command to hold references to UI elements. Consider this example:

```
build BentoRectangle {
	ltrb = [20, 20, parent.width-20, parent.height-20]

	var firstChild = build BentoRectangle {
		ltrb = [20, 20, parent.width/2 - 10, parent.height-20]
	}

	//Create the second rectangle below the first rectangle
	build BentoRectangle {
		x      = topChild.x
		y      = topChild.height + 20
		width  = topChild.width
		height = topChild.height
	}
}
```

In this example, we're creating a local variable (`var firstChild`) that stores a reference to a rectangle. We're then creating a second rectangle beneath it with a 20px space between the two. Both rectangles share the same width and height.

&nbsp;

## Variables

?> You can read a full list of shared variables [here](Shared-Variables). Each UI template also has its own set of special variables specific to that template so make sure to read the documentation thoroughly to understand what's available.

There are many, many variables that you can read and adjust for a UI element. You've seen a few already - `x` `y` `width` `height`. You'll notice a special variable called `ltrb` as well. Variables in BentoScript behave similarly to GML. They're weakly typed to begin with, and variables types can be one of the following: boolean, number, string, array, struct, functions, or undefined. You can create local variables with `var` and variables without a prefix (e.g. `x` as opposed to `topChild.x`) are presumed to be variables available in the current scope.

BentoScript adds an extra feature on top of standard GML variables, however, and that's getter and setter functions for variables. Normally when you get and set a variable in GML you're just reading and writing variables. There's nothing else that happens. In building out Bento, however, I found that it's really useful to execute implicit behaviours when setting variables.

As an example, let's look at `ltrb`. This is a shorthand for "left, top, right, bottom" and, as you might have guessed, this variable sets the bounding box for a UI element based on a 4-element array. Internally, there is no `ltrb` variable. It's a trick! In reality, the `ltrb` variable has special getter and setter functions set up. When you set the `ltrb`variable, the four components of the array are unpacked into separate left, top, right, and bottom variables. When you get the `ltrb` variable, these four components are recombined into an array.

In fact, the majority of variables that you'll use with BentoScript are implemented as getter / setter functions. When building custom UI templates for yourself you'll likely want to be able to define your own getter / setter functions too. You can call the `VariableBind()` method to set up getter / setter functions for yourself.

!> When writing GML code to interface with Bento, it is strongly recommended that you use the `Get()` and `Set()` methods for reading and writing variables. Getter / Setter functions will only work in GML if you use these two methods!

&nbsp;

## Callbacks

?> You can read a full list of shared callbacks [here](Shared-Callbacks).

&nbsp;

## Methods

?> You can read a full list of shared callbacks [here](Shared-Methods).