# Introduction

Bento is a user interface framework. It is intended to be used for player-facing UI rather than, say, debug menus. I've tried to make iterating on your UI implementation as fast as possible within Bento.


Bento is not like my other libraries where I typically try to cover the majority of use-cases with a single API though; user interfaces are so varied and so central to the feel of a game that a single API is a doomed endeavour.

- Templates
- User input
- Layers
- Live reloading
- Native gamepad support
- Expansion necessary
- Works on phone

During its (long and painful) development, Bento ended up getting complicated. I've done my best to hide some of the gnarlier details but there's still a lot to learn. Here's a brief overview of how Bento is structured which hopefully helps you understand what's going on.

&nbsp;

## Live Programming

The feature of Bento that I'm most proud of is the live programming. This allows you to edit UI code whilst the game is running and immediately see the difference. This is incredibly useful and saves so, so much time. In order to achieve this, I've linked Bento to a custom scripting language for UI called BentoScript. It has some carefully chosen syntax and behaviour which allows for uncomplicated UI layouts using code. Because we're using a custom language, Bento can reload UI code in realtime which opens up a world of possibilities.

Having said that, you can still use Bento without BentoScript. The Bento API is fully available through GML and you lose nothing but convenience if you decide to use only the GML portion of Bento. You can read more about BentoScript [here](BentoScript).

?> Despite being immensely proud of the live programming feature, I didn't write most of it! Bento's custom scripting language (BentoScript) is a modified version of the incomparable [Catspeak](https://github.com/katsaii/catspeak-lang) by [Katsaii](https://www.katsaii.com/). I highly recommend investigating Catspeak if you need any sort of flexible scripting solution for your game.

&nbsp;

## Bento Boxes

The basic unit of logic in Bento is the "box". A Bento box is implemented as a struct internally, and each Bento box has an array of children. By attaching child boxes to parent boxes recursively, we can build a tree of UI elements. This is similar to the "document object model" if you're familiar with HTML and web tech in general.

As a practical example, consider a small pause menu that appears in the centre of the screen. The pause menu background occupies a small portion of the screen rather than filling it. The buttons on the pause menu are children of the pause menu background, and the menu background is the parent.

By attaching child boxes to parent boxes we create a hierarchy that is helpful for resolving mouse events, ordering draw calls, calculating layouts, and generally organising the appearance of the user interface. You can read more about the capabilities of Bento boxes [here](Bento-Boxes).

&nbsp;

## Templates & Customisation

As mentioned, a Bento box is implemented as a struct. Needless to say, a box is a special type of box. All boxes are generated by instantiating constructors, and those constructors all (through a chain of inheritance) inherit from the same base constructor `BentoClassShared`. Bento offers several basic UI templates ("widgets") as constructors. For example, the sprite button constructor `BentoClassSpriteButton` inherits from `BentoClassButton` which in turn inherits from `BentoClassShared`.

?> If you're not familiar with constructor inheritance, check out [GameMaker's documentation](https://manual.yoyogames.com/index.htm#t=GameMaker_Language%2FGML_Overview%2FStructs.htm&rhsearch=Inheritance&rhhlterm=Inheritance) on the topic.

There's no conceivable way that I could cover every UI use case with Bento. As a result, Bento is built to be easily extensible. In order to customise Bento, all you need to do is create a new constructor and inherit from the template of your choice. If you'd like to make a special kind of slider, you can inherit from `BentoClassHorizontalSlider` and start customising. This will require some effort on your part, but it's worth it.

If you'd like to make something totally custom then you'll want to inherit directly from `BentoClassShared` and fill in the various variables and callbacks as you see fit.

You can read more about the various templates that available to you [here](Bento-Templates).

&nbsp;

## Callbacks

Bento uses a callback model for linking your user interface to your functional code.

&nbsp;

## Layers

Bento UI elements are arranged on layers. Each layer has precisely one root Bento box which acts as the tying-off point for whatever UI layout you need to exist on that layer. Layers must have unique names. Layers additionally have a `priority` variable that controls the order that Bento layers are processed (for both user inout and drawing purposes). Layers have methods that allow them to be placed over other layers, to be pushed to the very top of the stack, or to be drawn at a specific priority.

T#he behaviour of Bento boxes stored on layers can be controlled by setting the `behavior` variable on a layer. This behaviour variable can be used to change how Bento boxes on that layer function, but it is also used to control how subsequent (deeper / later) layers behave too. For example, a layer whose behaviour is set to `BENTO_BEHAVIOR_BLOCKING` will prevent all subsequent layers from receiving input or even drawing.

&nbsp;

## User Input

Bento is built with both desktop mice, mobile touchscreens, and console gamepads in mind. Bento supports gamepad-based navigation out of the box and, unless you've customised things really heavily, you should have no issue swapping between mouse-driven and gamepad-driven user input modes. Bento uses a raycasting technique to determine which button to highlight so, even without direct assistance, Bento works with gamepads as well as mice.

User input is handled by passing button state into Bento, wherein Bento decides whether a button has been pressed, released, held, or none of the above. Gone are the days of meticulously programming mouse button checks for every UI element. Bento also differentiates between "clicks" (which are actions directed at a specific UI element) and "casts" (which are actions broadcast more generally). For example, right-clicking on an item to open a context menu is a "click" and pressing Escape to close a pause menu is a "cast".